# Trading Signals

This document provides a comprehensive overview of the trading signal generation system, which is a core component of the AI-powered trading bot.

## Overview

Trading signals are actionable recommendations generated by the system to guide trading decisions. The trading signal generation system combines multiple strategies and data sources to produce high-quality signals with confidence metrics.

## Signal Generation Architecture

The trading signal generation process follows a multi-layered approach:

```
┌─────────────────────────────────────────────────────────────┐
│                  Trading Signal Generation                   │
└───────────────────────────────┬─────────────────────────────┘
                                │
            ┌─────────────────────────────────────┐
            │                                     │
┌───────────▼───────────┐   ┌───────────▼───────────┐   ┌───────────▼───────────┐
│  Technical Analysis   │   │    ML-Based Models   │   │  Sentiment Analysis   │
│       Signals         │   │       Signals        │   │       Signals         │
└───────────┬───────────┘   └───────────┬───────────┘   └───────────┬───────────┘
            │                           │                           │
            └─────────────┬─────────────┴─────────────┬─────────────┘
                          │                           │
              ┌───────────▼───────────┐   ┌───────────▼───────────┐
              │   Signal Aggregation  │   │    Risk Management    │
              │    & Prioritization   │   │       Filtering       │
              └───────────┬───────────┘   └───────────┬───────────┘
                          │                           │
                          └─────────────┬─────────────┘
                                        │
                            ┌───────────▼───────────┐
                            │   Final Signal with   │
                            │ Confidence & Metrics  │
                            └───────────────────────┘
```

## Signal Types and Sources

The system generates three main types of trading signals:

### 1. Technical Analysis Signals

Generated by the `TechnicalAnalysisService` based on traditional technical indicators and chart patterns.

```python
def _generate_technical_signals(self, symbol: str, timeframe: str = '1h') -> List[Dict[str, Any]]:
    # Get technical analysis service
    ta_service = TechnicalAnalysisService(self.db)
    
    # Calculate indicators
    indicators = ta_service.calculate_indicators(symbol, 'binance', timeframe)
    
    if not indicators.get('success', False):
        return []
    
    signals = []
    trend_indicators = indicators['indicators'].get('trend_indicators', {})
    momentum_indicators = indicators['indicators'].get('momentum_indicators', {})
    
    # Check for SMA crossover
    if all(k in trend_indicators for k in ['sma_20', 'sma_50']):
        sma_20 = trend_indicators['sma_20']
        sma_50 = trend_indicators['sma_50']
        
        if sma_20 > sma_50:
            signals.append({
                'symbol': symbol,
                'signal_type': 'BUY',
                'strategy': 'SMA_CROSSOVER',
                'strength': 0.7,
                'confidence': 0.65,
                'source': 'technical',
                'description': 'SMA 20 crossed above SMA 50'
            })
        elif sma_20 < sma_50:
            signals.append({
                'symbol': symbol,
                'signal_type': 'SELL',
                'strategy': 'SMA_CROSSOVER',
                'strength': 0.7,
                'confidence': 0.65,
                'source': 'technical',
                'description': 'SMA 20 crossed below SMA 50'
            })
    
    # Check RSI for overbought/oversold conditions
    if 'rsi' in momentum_indicators:
        rsi_value = momentum_indicators['rsi'].get('value')
        if rsi_value is not None:
            if rsi_value < 30:  # Oversold
                signals.append({
                    'symbol': symbol,
                    'signal_type': 'BUY',
                    'strategy': 'RSI_OVERSOLD',
                    'strength': 0.8,
                    'confidence': 0.7,
                    'source': 'technical',
                    'description': f'RSI is oversold at {rsi_value:.2f}'
                })
            elif rsi_value > 70:  # Overbought
                signals.append({
                    'symbol': symbol,
                    'signal_type': 'SELL',
                    'strategy': 'RSI_OVERBOUGHT',
                    'strength': 0.8,
                    'confidence': 0.7,
                    'source': 'technical',
                    'description': f'RSI is overbought at {rsi_value:.2f}'
                })
    
    # Add more technical signals based on other indicators...
    
    return signals
```

#### Key Technical Signal Strategies

| Strategy | Description | Indicators Used |
|----------|-------------|----------------|
| SMA Crossover | Signals based on moving average crossovers | SMA 20, SMA 50, SMA 200 |
| RSI Conditions | Identifies overbought/oversold conditions | RSI |
| MACD Crossover | Signals based on MACD line crossing signal line | MACD |
| Bollinger Band Breakouts | Identifies price breakouts from volatility bands | Bollinger Bands |
| Support/Resistance Breaks | Signals when price breaks key levels | Support/Resistance levels |
| Chart Pattern Completion | Identifies completed chart patterns | Various patterns |

### 2. ML-Based Signals

Generated by machine learning models trained on historical price data and features.

```python
def _generate_ml_signals(self, symbol: str, timeframe: str = '1h') -> List[Dict[str, Any]]:
    signals = []
    
    try:
        # Get market data for prediction
        market_data = self._get_market_data(symbol, timeframe, 100)
        if not market_data or len(market_data) < 50:
            return []
        
        # Prepare features for ML model
        features_df = self._prepare_ml_features(market_data)
        if features_df is None or features_df.empty:
            return []
        
        # Make prediction using ML model
        prediction = self._predict_price_direction(features_df)
        if prediction is None:
            return []
        
        # Generate signal based on prediction
        if prediction > 0.6:  # Bullish prediction
            signals.append({
                'symbol': symbol,
                'signal_type': 'BUY',
                'strategy': 'ML_PREDICTION',
                'strength': min(prediction * 1.2, 1.0),  # Scale prediction to strength
                'confidence': prediction,
                'source': 'ml_model',
                'description': f'ML model predicts upward movement with {prediction:.2f} confidence'
            })
        elif prediction < 0.4:  # Bearish prediction
            bearish_confidence = 1 - prediction
            signals.append({
                'symbol': symbol,
                'signal_type': 'SELL',
                'strategy': 'ML_PREDICTION',
                'strength': min(bearish_confidence * 1.2, 1.0),
                'confidence': bearish_confidence,
                'source': 'ml_model',
                'description': f'ML model predicts downward movement with {bearish_confidence:.2f} confidence'
            })
    
    except Exception as e:
        logger.error(f"Error generating ML signals for {symbol}: {str(e)}")
    
    return signals
```

#### ML Model Architecture

The ML signal generation uses a combination of models:

1. **Price Direction Prediction**
   - Model Type: LSTM (Long Short-Term Memory) neural network
   - Features: Technical indicators, price patterns, volume metrics
   - Output: Probability of price moving up in the next period

2. **Price Range Prediction**
   - Model Type: Gradient Boosting Regression
   - Features: Market volatility, recent price action, technical indicators
   - Output: Predicted price range for the next period

3. **Anomaly Detection**
   - Model Type: Isolation Forest
   - Features: Price, volume, volatility metrics
   - Output: Identification of unusual market conditions

### 3. Sentiment Analysis Signals

Generated by analyzing market sentiment from news, social media, and other sources.

```python
def _generate_sentiment_signals(self, symbol: str) -> List[Dict[str, Any]]:
    signals = []
    
    try:
        # Get recent news and social media sentiment
        sentiment_data = self._get_sentiment_data(symbol)
        if not sentiment_data:
            return []
        
        # Calculate overall sentiment score (-1 to 1 scale)
        overall_sentiment = sentiment_data.get('overall_score', 0)
        news_sentiment = sentiment_data.get('news_score', 0)
        social_sentiment = sentiment_data.get('social_score', 0)
        
        # Generate signal based on strong sentiment
        if overall_sentiment > 0.6:  # Strong positive sentiment
            signals.append({
                'symbol': symbol,
                'signal_type': 'BUY',
                'strategy': 'SENTIMENT_ANALYSIS',
                'strength': min(overall_sentiment * 1.2, 1.0),
                'confidence': overall_sentiment,
                'source': 'sentiment',
                'description': f'Strong positive sentiment detected (score: {overall_sentiment:.2f})'
            })
        elif overall_sentiment < -0.6:  # Strong negative sentiment
            negative_confidence = abs(overall_sentiment)
            signals.append({
                'symbol': symbol,
                'signal_type': 'SELL',
                'strategy': 'SENTIMENT_ANALYSIS',
                'strength': min(negative_confidence * 1.2, 1.0),
                'confidence': negative_confidence,
                'source': 'sentiment',
                'description': f'Strong negative sentiment detected (score: {overall_sentiment:.2f})'
            })
        
        # Check for sentiment divergence between news and social media
        if news_sentiment > 0.5 and social_sentiment < -0.5:
            signals.append({
                'symbol': symbol,
                'signal_type': 'ALERT',
                'strategy': 'SENTIMENT_DIVERGENCE',
                'strength': 0.6,
                'confidence': 0.6,
                'source': 'sentiment',
                'description': 'Divergence between positive news and negative social sentiment'
            })
    
    except Exception as e:
        logger.error(f"Error generating sentiment signals for {symbol}: {str(e)}")
    
    return signals
```

#### Sentiment Analysis Sources

| Source | Description | Weight |
|--------|-------------|--------|
| Financial News | Articles from major financial publications | 0.4 |
| Twitter/X | Tweets from influential crypto accounts | 0.3 |
| Reddit | Posts from cryptocurrency subreddits | 0.2 |
| GitHub | Development activity on blockchain projects | 0.1 |

## Signal Aggregation and Prioritization

The system combines signals from multiple sources and strategies to produce final trading recommendations.

```python
def generate_trading_signals(self, symbol: str, signal_types: List[str] = None, timeframe: str = '1h') -> List[Dict[str, Any]]:
    if signal_types is None:
        signal_types = ['technical', 'ml', 'sentiment']
    
    all_signals = []
    
    # Generate signals from different sources based on requested types
    if 'technical' in signal_types:
        technical_signals = self._generate_technical_signals(symbol, timeframe)
        all_signals.extend(technical_signals)
    
    if 'ml' in signal_types:
        ml_signals = self._generate_ml_signals(symbol, timeframe)
        all_signals.extend(ml_signals)
    
    if 'sentiment' in signal_types:
        sentiment_signals = self._generate_sentiment_signals(symbol)
        all_signals.extend(sentiment_signals)
    
    # Apply risk management filters
    filtered_signals = self._apply_risk_filters(all_signals, symbol)
    
    # Aggregate similar signals and calculate combined metrics
    aggregated_signals = self._aggregate_signals(filtered_signals)
    
    # Sort by confidence and strength
    sorted_signals = sorted(
        aggregated_signals,
        key=lambda x: (x.get('confidence', 0) * 0.7 + x.get('strength', 0) * 0.3),
        reverse=True
    )
    
    # Store signals in database
    self._store_signals(sorted_signals)
    
    return sorted_signals
```

### Signal Aggregation Logic

```python
def _aggregate_signals(self, signals: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    if not signals:
        return []
    
    # Group signals by symbol and signal_type
    grouped_signals = {}
    for signal in signals:
        key = (signal['symbol'], signal['signal_type'])
        if key not in grouped_signals:
            grouped_signals[key] = []
        grouped_signals[key].append(signal)
    
    aggregated_signals = []
    
    # Aggregate each group
    for (symbol, signal_type), signal_group in grouped_signals.items():
        if len(signal_group) == 1:
            # Only one signal of this type, no need to aggregate
            aggregated_signals.append(signal_group[0])
        else:
            # Multiple signals of same type, aggregate them
            avg_strength = sum(s.get('strength', 0) for s in signal_group) / len(signal_group)
            avg_confidence = sum(s.get('confidence', 0) for s in signal_group) / len(signal_group)
            
            # Boost confidence if multiple sources agree
            source_types = set(s.get('source') for s in signal_group)
            if len(source_types) > 1:
                confidence_boost = min(0.1 * len(source_types), 0.2)  # Max 20% boost
                avg_confidence = min(avg_confidence + confidence_boost, 1.0)
            
            # Combine descriptions
            descriptions = [s.get('description', '') for s in signal_group]
            combined_desc = '; '.join(descriptions[:3])
            if len(descriptions) > 3:
                combined_desc += f'; and {len(descriptions) - 3} more signals'
            
            # Create aggregated signal
            aggregated_signal = {
                'symbol': symbol,
                'signal_type': signal_type,
                'strategy': 'MULTI_STRATEGY',
                'strength': avg_strength,
                'confidence': avg_confidence,
                'source': ', '.join(source_types),
                'description': combined_desc,
                'component_signals': len(signal_group),
                'sources': list(source_types)
            }
            
            aggregated_signals.append(aggregated_signal)
    
    return aggregated_signals
```

## Risk Management Filtering

Before finalizing signals, the system applies risk management filters to ensure they align with the user's risk profile and market conditions.

```python
def _apply_risk_filters(self, signals: List[Dict[str, Any]], symbol: str) -> List[Dict[str, Any]]:
    if not signals:
        return []
    
    filtered_signals = []
    
    # Get current market conditions
    market_conditions = self._get_market_conditions(symbol)
    
    # Get user risk profile
    risk_profile = self._get_user_risk_profile()
    
    for signal in signals:
        # Skip low confidence signals
        if signal.get('confidence', 0) < risk_profile.get('min_signal_confidence', 0.5):
            continue
        
        # Check market volatility conditions
        if market_conditions.get('high_volatility', False) and risk_profile.get('avoid_high_volatility', False):
            if signal.get('signal_type') != 'ALERT':  # Allow alerts even in high volatility
                continue
        
        # Check trading hours restrictions
        if not self._is_within_trading_hours(risk_profile):
            continue
        
        # Check portfolio exposure limits
        if not self._check_exposure_limits(symbol, signal, risk_profile):
            continue
        
        # Signal passed all filters
        filtered_signals.append(signal)
    
    return filtered_signals
```

### Risk Profile Parameters

| Parameter | Description | Default Value |
|-----------|-------------|---------------|
| min_signal_confidence | Minimum confidence threshold for signals | 0.5 |
| avoid_high_volatility | Whether to avoid trading in high volatility | True |
| trading_hours_start | Start of allowed trading hours (UTC) | 0 (24h trading) |
| trading_hours_end | End of allowed trading hours (UTC) | 24 (24h trading) |
| max_asset_exposure | Maximum exposure to a single asset | 0.2 (20%) |
| max_total_exposure | Maximum total portfolio exposure | 0.8 (80%) |

## Signal Database Schema

Trading signals are stored in the database using the `TradingSignal` model:

```python
class TradingSignal(Base):
    __tablename__ = "trading_signals"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    symbol = Column(String, nullable=False, index=True)
    signal_type = Column(Enum('BUY', 'SELL', 'ALERT', name='signal_type_enum'), nullable=False)
    strategy = Column(String, nullable=False)
    strength = Column(Float, nullable=False)  # 0.0 to 1.0
    confidence = Column(Float, nullable=False)  # 0.0 to 1.0
    source = Column(String, nullable=False)  # technical, ml_model, sentiment, multi
    description = Column(String)
    entry_price = Column(Float)
    target_prices = Column(JSONB)  # Multiple target levels
    stop_loss_price = Column(Float)
    timeframe = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime)
    status = Column(Enum('ACTIVE', 'EXECUTED', 'EXPIRED', 'INVALIDATED', name='signal_status_enum'), 
                   default='ACTIVE')
    executed_at = Column(DateTime)
    execution_price = Column(Float)
    profit_loss = Column(Float)
    metadata = Column(JSONB)  # Additional signal data
    
    # Relationships
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    user = relationship("User", back_populates="trading_signals")
```

## Signal Lifecycle Management

The system manages the complete lifecycle of trading signals:

### 1. Signal Creation

```python
def _store_signals(self, signals: List[Dict[str, Any]]) -> None:
    try:
        for signal_data in signals:
            # Calculate expiration time based on timeframe
            timeframe = signal_data.get('timeframe', '1h')
            expires_at = self._calculate_expiration_time(timeframe)
            
            # Create signal record
            signal = TradingSignal(
                symbol=signal_data['symbol'],
                signal_type=signal_data['signal_type'],
                strategy=signal_data.get('strategy', 'UNKNOWN'),
                strength=signal_data.get('strength', 0.5),
                confidence=signal_data.get('confidence', 0.5),
                source=signal_data.get('source', 'unknown'),
                description=signal_data.get('description', ''),
                entry_price=signal_data.get('entry_price'),
                target_prices=signal_data.get('target_prices'),
                stop_loss_price=signal_data.get('stop_loss_price'),
                timeframe=timeframe,
                created_at=datetime.utcnow(),
                expires_at=expires_at,
                status='ACTIVE',
                metadata={
                    'component_signals': signal_data.get('component_signals'),
                    'sources': signal_data.get('sources'),
                    'raw_data': signal_data.get('raw_data')
                }
            )
            
            self.db.add(signal)
        
        self.db.commit()
        
    except Exception as e:
        logger.error(f"Error storing trading signals: {str(e)}")
        self.db.rollback()
```

### 2. Signal Tracking and Updates

```python
def update_signal_status(self, signal_id: str, new_status: str, execution_data: Dict[str, Any] = None) -> bool:
    try:
        signal = self.db.query(TradingSignal).filter(TradingSignal.id == signal_id).first()
        
        if not signal:
            return False
        
        signal.status = new_status
        
        if new_status == 'EXECUTED' and execution_data:
            signal.executed_at = datetime.utcnow()
            signal.execution_price = execution_data.get('price')
            
            # Calculate profit/loss if applicable
            if signal.entry_price and signal.execution_price:
                if signal.signal_type == 'BUY':
                    signal.profit_loss = (signal.execution_price - signal.entry_price) / signal.entry_price
                else:  # SELL
                    signal.profit_loss = (signal.entry_price - signal.execution_price) / signal.entry_price
        
        self.db.commit()
        return True
        
    except Exception as e:
        logger.error(f"Error updating signal status: {str(e)}")
        self.db.rollback()
        return False
```

### 3. Signal Expiration

```python
def expire_outdated_signals(self) -> int:
    try:
        # Find all active signals that have passed their expiration time
        expired_signals = self.db.query(TradingSignal).filter(
            TradingSignal.status == 'ACTIVE',
            TradingSignal.expires_at < datetime.utcnow()
        ).all()
        
        # Update their status to EXPIRED
        for signal in expired_signals:
            signal.status = 'EXPIRED'
        
        self.db.commit()
        return len(expired_signals)
        
    except Exception as e:
        logger.error(f"Error expiring outdated signals: {str(e)}")
        self.db.rollback()
        return 0
```

## Signal Performance Analysis

The system tracks and analyzes the performance of generated signals to improve future predictions.

```python
def analyze_signal_performance(self, timeframe: str = '7d') -> Dict[str, Any]:
    try:
        # Calculate the start date based on timeframe
        if timeframe == '24h':
            start_date = datetime.utcnow() - timedelta(days=1)
        elif timeframe == '7d':
            start_date = datetime.utcnow() - timedelta(days=7)
        elif timeframe == '30d':
            start_date = datetime.utcnow() - timedelta(days=30)
        else:
            start_date = datetime.utcnow() - timedelta(days=30)  # Default
        
        # Get all executed or expired signals in the timeframe
        signals = self.db.query(TradingSignal).filter(
            TradingSignal.created_at >= start_date,
            TradingSignal.status.in_(['EXECUTED', 'EXPIRED'])
        ).all()
        
        if not signals:
            return {
                'total_signals': 0,
                'performance': 'No signals in the specified timeframe'
            }
        
        # Calculate performance metrics
        total_signals = len(signals)
        executed_signals = sum(1 for s in signals if s.status == 'EXECUTED')
        expired_signals = total_signals - executed_signals
        
        # Calculate profit/loss metrics for executed signals
        profitable_signals = sum(1 for s in signals if s.status == 'EXECUTED' and s.profit_loss and s.profit_loss > 0)
        losing_signals = sum(1 for s in signals if s.status == 'EXECUTED' and s.profit_loss and s.profit_loss <= 0)
        
        # Calculate average profit/loss
        profit_loss_values = [s.profit_loss for s in signals if s.status == 'EXECUTED' and s.profit_loss is not None]
        avg_profit_loss = sum(profit_loss_values) / len(profit_loss_values) if profit_loss_values else 0
        
        # Calculate performance by source
        performance_by_source = {}
        for source in ['technical', 'ml_model', 'sentiment', 'multi']:
            source_signals = [s for s in signals if s.source == source]
            if not source_signals:
                continue
                
            source_profit_loss = [s.profit_loss for s in source_signals if s.status == 'EXECUTED' and s.profit_loss is not None]
            source_avg_pl = sum(source_profit_loss) / len(source_profit_loss) if source_profit_loss else 0
            
            performance_by_source[source] = {
                'total': len(source_signals),
                'executed': sum(1 for s in source_signals if s.status == 'EXECUTED'),
                'expired': sum(1 for s in source_signals if s.status == 'EXPIRED'),
                'avg_profit_loss': source_avg_pl,
                'win_rate': sum(1 for s in source_signals if s.status == 'EXECUTED' and s.profit_loss and s.profit_loss > 0) / 
                           sum(1 for s in source_signals if s.status == 'EXECUTED' and s.profit_loss is not None) 
                           if sum(1 for s in source_signals if s.status == 'EXECUTED' and s.profit_loss is not None) > 0 else 0
            }
        
        return {
            'timeframe': timeframe,
            'total_signals': total_signals,
            'executed_signals': executed_signals,
            'expired_signals': expired_signals,
            'execution_rate': executed_signals / total_signals if total_signals > 0 else 0,
            'profitable_signals': profitable_signals,
            'losing_signals': losing_signals,
            'win_rate': profitable_signals / executed_signals if executed_signals > 0 else 0,
            'avg_profit_loss': avg_profit_loss,
            'by_source': performance_by_source
        }
        
    except Exception as e:
        logger.error(f"Error analyzing signal performance: {str(e)}")
        return {
            'error': str(e),
            'total_signals': 0
        }
```

## API Endpoints

The trading signals are exposed through the following API endpoints:

### 1. Generate Trading Signals

```
POST /api/v1/ai/trading-signals
```

**Request Body:**
```json
{
  "symbols": ["BTC/USDT", "ETH/USDT"],
  "signal_types": ["technical", "ml", "sentiment"],
  "timeframe": "1h",
  "risk_level": "medium",
  "strategy_preference": "balanced"
}
```

**Response:**
```json
{
  "success": true,
  "signals": [
    {
      "signal_id": "f8a7c6b5-e4d3-42a1-9b8c-7d6e5f4a3b2c",
      "symbol": "BTC/USDT",
      "signal_type": "BUY",
      "strength": 0.85,
      "confidence": 0.78,
      "source": "technical, ml_model",
      "strategy": "MULTI_STRATEGY",
      "description": "RSI is oversold at 28.50; ML model predicts upward movement with 0.75 confidence",
      "entry_price": 42500.0,
      "target_prices": {
        "tp1": 43350.0,
        "tp2": 44200.0,
        "tp3": 45050.0
      },
      "stop_loss_price": 41650.0,
      "timeframe": "1h",
      "created_at": "2023-06-15T14:30:45Z",
      "expires_at": "2023-06-15T15:30:45Z"
    },
    {
      "signal_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6",
      "symbol": "ETH/USDT",
      "signal_type": "SELL",
      "strength": 0.72,
      "confidence": 0.65,
      "source": "sentiment",
      "strategy": "SENTIMENT_ANALYSIS",
      "description": "Strong negative sentiment detected (score: -0.68)",
      "entry_price": 2250.0,
      "target_prices": {
        "tp1": 2205.0,
        "tp2": 2160.0,
        "tp3": 2115.0
      },
      "stop_loss_price": 2295.0,
      "timeframe": "1h",
      "created_at": "2023-06-15T14:30:45Z",
      "expires_at": "2023-06-15T15:30:45Z"
    }
  ]
}
```

### 2. Get Signal Details

```
GET /api/v1/ai/trading-signals/{signal_id}
```

**Response:**
```json
{
  "success": true,
  "signal": {
    "signal_id": "f8a7c6b5-e4d3-42a1-9b8c-7d6e5f4a3b2c",
    "symbol": "BTC/USDT",
    "signal_type": "BUY",
    "strength": 0.85,
    "confidence": 0.78,
    "source": "technical, ml_model",
    "strategy": "MULTI_STRATEGY",
    "description": "RSI is oversold at 28.50; ML model predicts upward movement with 0.75 confidence",
    "entry_price": 42500.0,
    "target_prices": {
      "tp1": 43350.0,
      "tp2": 44200.0,
      "tp3": 45050.0
    },
    "stop_loss_price": 41650.0,
    "timeframe": "1h",
    "created_at": "2023-06-15T14:30:45Z",
    "expires_at": "2023-06-15T15:30:45Z",
    "status": "ACTIVE",
    "executed_at": null,
    "execution_price": null,
    "profit_loss": null,
    "metadata": {
      "component_signals": 2,
      "sources": ["technical", "ml_model"],
      "raw_data": {
        "technical_indicators": {
          "rsi": 28.5,
          "sma_20": 41200.0,
          "sma_50": 40800.0
        },
        "ml_prediction": 0.75
      }
    }
  }
}
```

### 3. Get Active Signals

```
GET /api/v1/ai/trading-signals/active
```

**Query Parameters:**
- `symbol` (optional): Filter by symbol
- `signal_type` (optional): Filter by signal type (BUY, SELL, ALERT)
- `min_confidence` (optional): Minimum confidence threshold

**Response:**
```json
{
  "success": true,
  "count": 2,
  "signals": [
    {
      "signal_id": "f8a7c6b5-e4d3-42a1-9b8c-7d6e5f4a3b2c",
      "symbol": "BTC/USDT",
      "signal_type": "BUY",
      "strength": 0.85,
      "confidence": 0.78,
      "source": "technical, ml_model",
      "description": "RSI is oversold at 28.50; ML model predicts upward movement with 0.75 confidence",
      "entry_price": 42500.0,
      "created_at": "2023-06-15T14:30:45Z",
      "expires_at": "2023-06-15T15:30:45Z"
    },
    {
      "signal_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6",
      "symbol": "ETH/USDT",
      "signal_type": "SELL",
      "strength": 0.72,
      "confidence": 0.65,
      "source": "sentiment",
      "description": "Strong negative sentiment detected (score: -0.68)",
      "entry_price": 2250.0,
      "created_at": "2023-06-15T14:30:45Z",
      "expires_at": "2023-06-15T15:30:45Z"
    }
  ]
}
```

### 4. Get Signal Performance

```
GET /api/v1/ai/trading-signals/performance
```

**Query Parameters:**
- `timeframe` (optional): Analysis timeframe (24h, 7d, 30d)

**Response:**
```json
{
  "success": true,
  "performance": {
    "timeframe": "7d",
    "total_signals": 120,
    "executed_signals": 85,
    "expired_signals": 35,
    "execution_rate": 0.71,
    "profitable_signals": 52,
    "losing_signals": 33,
    "win_rate": 0.61,
    "avg_profit_loss": 0.023,
    "by_source": {
      "technical": {
        "total": 65,
        "executed": 48,
        "expired": 17,
        "avg_profit_loss": 0.018,
        "win_rate": 0.58
      },
      "ml_model": {
        "total": 30,
        "executed": 22,
        "expired": 8,
        "avg_profit_loss": 0.031,
        "win_rate": 0.68
      },
      "sentiment": {
        "total": 15,
        "executed": 9,
        "expired": 6,
        "avg_profit_loss": 0.015,
        "win_rate": 0.56
      },
      "multi": {
        "total": 10,
        "executed": 6,
        "expired": 4,
        "avg_profit_loss": 0.042,
        "win_rate": 0.83
      }
    }
  }
}
```

## Conclusion

The trading signal generation system is a sophisticated component that combines multiple analysis techniques to produce actionable trading recommendations. By leveraging technical analysis, machine learning, and sentiment analysis, the system can identify trading opportunities across different market conditions and timeframes.

The modular architecture allows for easy extension with new signal sources and strategies, while the comprehensive performance tracking enables continuous improvement of the signal generation algorithms.